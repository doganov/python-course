* Упражнения

** Част III.  Конструкции и синтаксис.

*** 1. Кодиране на основни цикли

    a) Напишете цикъл `for', който извежда кода ASCII на всеки символ
       от символния низ, наречен S.  Приема се, че S може да съдържа
       само символи от подмножеството на кодовата таблица ASCII.
       Използвайте вградената функция `ord(CHARACTER)', за да
       преобразувате всеки символ в цяло число от ASCII.  (Изпробвайте
       я интерактивно, за да видите как работи.)

    б) След това променете цикъла си, така че да изчислява сбора на
       кодовете ASCII на всички символи от даден низ.

    в) И накрая, променете кода си отново, така че да върне нов
       списък, който съдържа кодовете ASCII на всеки от символите в
       низа.

*** 2. Сортиране на речници

    Знаем, че речниците са неподредени съвкупности.  Напишете цикъл
    `for', който визуализира елементите от речник в сортиран
    (възходящ) ред.  Съвет: използвайте метода на речник `keys' и
    метода на списък `sort'.

*** 3. Варианти на програмната логика

    Нека разгледаме следващия код, който използва цикъл `while' и флаг
    `found', за да претърси списък със степени на 2 за стойността на
    2, повдигнато на пета степен (32).  Той се съхранява в скриптов
    файл, наречен `power.py'.

        L = [1, 2, 4, 8, 16, 32, 64]
        X = 5

        found = i = 0
        while not found and i < len(L):
            if 2 ** X == L[i]:
                found = 1
            else:
                i = i + 1

        if found:
            print 'at index', i
        else:
            print X, 'not found'


        $ python power.py
        at index 5

    В този си вид примерът не спазва обичайните начини за кодиране на
    Питон.  Преминете през стъпките по-долу, за да го поправите.  При
    всяка от промените можете да пишете кода си интерактивно или да го
    запишете в скриптов файл, който да стартирате от системния
    команден ред (използването на файл значително улеснява
    упражнението).

        a) Най-напред пренапишете този код с цикъл `while' и клауза
           `else', за да премахнете флага `found' и последната
           конструкция `if'.

        б) След това пренапишете примера, така че да използва цикъл
          `for' с клауза `else', за да се премахне логиката на
          изричното обръщение към елемент по индекс (`L[i]').  Съвет:
          за да получите индекса на определен елемент, използвайте
          метода на списък `index'.  (`L.index(X)' връща индекса на
          първия X в списък L).

        в) После напълно премахнете цикъла, като пренапишете примерите
           с прост израз за проверка на член с оператора `in'.

        г) И накрая, използвайте цикъл `for' и метода на списък
          `append', за да генерирате списък L, съдържащ степени на 2,
          вместо ръчно да кодирате литерал за списък.

        д) Размишления:

           (1) Мислите ли, че производителността ще се увеличи, ако
               преместим израза `2**X' извън циклите?  Как бихте го
               кодирали?

           (2) Питон съдържа и функцията `map(FUNCTION, LIST)', чрез
               която също може да се генерира списък със степени на 2.
               Можете ли да пренапишете инициализационния код на L
               чрез `map' и `lambda'?

** Част IV.  Функции

   В тези упражнения ще започнем да кодираме по-сложни програми.
   Уверете се, че ще пишете кода си в скриптови файлове.  Няма да ви
   се иска да преписвате упражненията от самото начало, в случай, че
   някъде допуснете грешка.

*** 1. Основни принципи

    Напишете функция в интерактивния промпт на Питон, визуализираща
    единствения си аргумент на екрана, и я извикайте интерактивно,
    като ѝ подадете различни обектни типове: символен низ, цяло число,
    списък, речник.  Опитайте да я извикате, без да ѝ подадете
    аргумент.  Какво се случва?  Какво става, ако ѝ подадете два
    аргумента?

*** 2. Аргументи

    В скриптов файл на Питон напишете функция, наречена `adder'.
    Функцията `adder' трябва да приема два аргумента и да връща техния
    сбор (или конкатенация).  След това добавете код в долната част на
    файла, който да извиква функцията, като ѝ подава най-разнообразни
    обектни типове (два символни низа, два списъка, две числа с
    плаваща запетая), и стартирайте файла като скрипт от системния
    команден ред.  Трябва ли изрично да визуализирате резултатите от
    извикванията, за да можете да ги видите изписани на екрана?

*** 3. Произволен брой аргументи

    Разширете приложението на функцията `adder', която написахте в
    предишното упражнение, така че да изчислява сбора на произволен
    брой аргументи и променете извикванията към нея, така че да ѝ се
    подават повече или по-малко от два аргумента.  От какъв тип е
    върнатата стойност на сбора?  (Съвет: вградената функция `type'
    връща типа на дадена стойност.)  Какво се случва, когато подадете
    аргументи, които са от различни типове?  А ако подадете речници?

*** 4. Ключови думи

    Променете функцията `adder' от упражнение 2 така, че да приема и
    събира три аргумента: `def adder(good, bad, ugly)'.  А сега
    задайте стойности по подразбиране за всеки аргумент и
    поекспериментирайте, извиквайки функцията интерактивно.  Опитайте
    да ѝ подадете съответно един, два, три и четири аргумента.  След
    това опитайте да ѝ подадете аргументи с ключови думи.  успява ли
    извикването `adder(ugly=1, good=2)'?  Защо?  И накрая разширете
    приложението на новата функция `adder' така, че да приема
    произволен брой аргументи – ключови думи по подобие на упражнение
    3, но ще трябва да обходите речник, а не комплект.

*** 5. Копиране на речник

    Напишете функция, наречена `copyDict(DICT)', която копира своя
    аргумент речник.  Тя трябва да връща нов речник, който съдържа
    всички елементи от нейния аргумент.  Копирането на редици става
    лесно (`X[:]' създава копие на X); можем ли да използваме същия
    подход и за речниците?

*** 6. Събиране на речници

    Напишете функция, носеща името `addDict(DICT1, DICT2)', която да
    обединява два речника.  Тя трябва да връща нов речник, който
    съдържа всички елементи от двата ѝ аргумента (които приемаме, че
    са речници).  Ако един и същ ключ присъства и в двата речника,
    можете да изберете стойност от който и да е от тях.  Изпробвайте
    фукцията, като я напишете като файл и стартирате файла като
    скрипт.  Какво се случва, ако вместо речници подадете списъци?  По
    какъв начин можете да разширите приложението на функцията, така че
    да може да се използва и в този случай?  (Съвет: вижте вградената
    функция `type', която използвахме по-рано.)  Има ли значение редът
    на подаване на аргументите?

*** 7. Още примери за свързване на аргументи

    Най-напред дефинирайте следните шест функции (интерактивно):

        def f1(a, b): print a, b              # Нормални аргументи

        def f2(a, *b): print a, b             # Позиционни varargs

        def f3(a, **b): print a, b            # varargs с ключови думи

        def f4(a, *b, **c): print a, b, c     # Смесени режими на свързване

        def f5(a, b=2, c=3): print a, b, c    # Стойности по подразбиране

        def f6(a, b=2, *c): print a, b, c     # Стойности по подразбиране
                                              # и varargs

    След това изпробвайте интерактивно следващите извиквания и
    опитайте да обясните всеки от получените резултати.  Мислите ли,
    че смесването на режимите на свързване (позиционен режим и режим с
    ключови думи) е добра идея?  Можете ли да се сетите за случаи, при
    които то би било полезно?

        >>> f1(1, 2)
        >>> f1(b=2, a=1)

        >>> f2(1, 2, 3)
        >>> f3(1, x=2, y=3)
        >>> f4(1, 2, 3, x=2, y=3)

        >>> f5(1)
        >>> f5(1, 4)

        >>> f6(1)
        >>> f6(1, 3, 4)

*** 8. Прости числа

    Ето един отрязък код, който по доста прост начин определя дали
    дадено положително цяло число е просто:

        x = y / 2                         # За всяко y > 1
        while x > 1:
            if y % x == 0:                # Деление с остатък
                print y, 'has factor', x
                break                     # Прескача else
            x = x - 1
        else:                             # Нормален изход
            print y, 'is prime'

    Пакетирайте този код в скриптов файл като функция, която може да
    се използва многократно, и добавете няколко извиквания към нея в
    долната част на файла.  Заменете също оператора `/' от първия ред
    с `//', така че функцията да може да обработва и числа с плаваща
    запетая и да бъде „подготвена“ за предстоящата промяна на
    оператора `/' за „истинско“ деление в Питон 3.0.  Какво може да се
    направи за отрицателните числа, както и за 0 и 1?  А как да се
    ускори изпълнението на функцията?  Изходът на екрана би трябвало
    да изглежда по следния начин:

        13 is prime
        13.0 is prime
        15 has factor 5
        15.0 has factor 5.0

*** 9. Обхващане на списъци

    Напишете код, който да изгради нов списък, съдържащ квадратните
    корени на всички числа от следния списък `[2, 4, 9, 16, 25]'.
    Най-напред го направете с цикъл `for', после – с извикване на
    `map' и накрая като обхващане на списък.  Използвайте функцията
    `sqrt' от вградения модул `math', за да извършите изчислението
    (тоест импортирайте `math' и напишете `math.sqrt(X)').  Кой от
    трите начина ви допада най-много?
