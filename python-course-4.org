* 4. Повече средства за управление на изпълнението

  Освен току-що представената конструкция `while', Питон познава и
  обичайните конструкции за управление на изпълнението, познати от
  други езици, но с някои особености.

** 4.1. `if'-конструкции

   Може би най-познатият вид конструкции са `if'-конструкциите.
   Например:

       >>> x = int(raw_input("Please enter an integer: "))
       Please enter an integer: 42
       >>> if x < 0:
       ...      x = 0
       ...      print 'Negative changed to zero'
       ... elif x == 0:
       ...      print 'Zero'
       ... elif x == 1:
       ...      print 'Single'
       ... else:
       ...      print 'More'
       ...
       More

   Може да има нула или повече части `elif'.  Частта `else' е
   незадължителна.  Ключовата дума `elif' е съкратено име от „else
   if“, и е полезна за избягване на прекомерния отстъп.  Поредицата
   `if ...  elif ... elif ...' замества конструкциите `switch' или
   `case', които намираме в други езици.

** 4.2. `for'-конструкции

   Конструкцията `for' в Питон малко се различава от това, което може
   би сте използвали в C или Паскал.  Вместо винаги да се итерира
   върху някаква аритметична прогресия на числа (като в Паскал), или
   да се дава на потребителя възможност да определя както стъпката на
   итерация, така и условието за спиране (като в C), в Питон
   конструкцията `for' итерира върху елементите на каквато и да е
   редица (sequence) (напр. списък или символен низ), в реда, по който
   те се явяват в редицата.  Например (каламбурът е неволен):

       >>> # Да измерим няколко символни низа:
       ... a = ['cat', 'window', 'defenestrate']
       >>> for x in a:
       ...     print x, len(x)
       ...
       cat 3
       window 6
       defenestrate 12

   Не е безопасно да се променя редицата, докато се итерира върху нея
   в цикъл (това може да се случи само с изменяемите типове редици,
   т.е. списъците).  Ако трябва да променяте списъка върху който
   итерирате, напр. за да дублирате избрани елементи, тогава е
   необходимо да итерирате върху копие.  Нотацията за изрязване
   особено улеснява това:

       >>> for x in a[:]: # правим копие чрез изрязване на целия списък
       ...    if len(x) > 6: a.insert(0, x)
       ...
       >>> a
       ['defenestrate', 'cat', 'window', 'defenestrate']

** 4.3. Функцията `range()'

   Ако трябва да итерирате върху редица от числа, тогава идва на помощ
   вградената функция `range()'.  Тя генерира списъци, съдържащи
   аритметични прогресии, напр.:

       >>> range(10)
       [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

   Подадената крайна точка никога не е част от генерирания списък;
   `range(10)' генерира списък от 10 стойности, съвпадащи с обичайните
   индекси за елементите на редица с дължина 10.  Възможно е да
   накарате диапазона да започва от друго число, или да определите
   различна стъпка на увеличение (дори отрицателна):

       >>> range(5, 10)
       [5, 6, 7, 8, 9]
       >>> range(0, 10, 3)
       [0, 3, 6, 9]
       >>> range(-10, -100, -30)
       [-10, -40, -70]

   За да итерирате върху индексите в редица, комбинирайте функциите
   `range()' и `len()' както следва:

       >>> a = ['Когато', 'бях', 'овчарче', 'и', 'овците', 'пасях']
       >>> for i in range(len(a)):
       ...      print i, a[i]
       ...
       0 Когато
       1 бях
       2 овчарче
       3 и
       4 овците
       5 пасях

   В повечето такива случаи, обаче, е по-удобно да се използва
   функцията `enumerate()', виж раздел 5.6. Техники за реализиране на
   цикли.

** 4.4. Конструкции `break' и `continue'; клаузи `else' в циклите

   Конструкцията `break', както в C, излиза от най-вътрешния `for'-
   или `while'-цикъл.

   Конструкцията `continue', също взета назаем от C, продължава със
   следващата итерация в цикъла.

   Циклите могат да имат клауза `else'; тя се изпълнява когато цикълът
   завърши чрез изчерпване на списъка (при `for') или когато условието
   стане неистина (при `while'), но не и когато цикълът завърши с
   конструкция `break'.  Това е демонстрирано от следващия цикъл,
   който търси прости (неделими) числа:

       >>> for n in range(2, 10):
       ...     for x in range(2, n):
       ...         if n % x == 0:
       ...            print n, 'е равно на', x, '*', n/x
       ...            break
       ...     else:
       ...          print n, 'е просто число'
       ...
       2 е просто число
       3 е просто число
       4 е равно на 2 * 2
       5 е просто число
       6 е равно на 2 * 3
       7 е просто число
       8 е равно на 2 * 4
       9 е равно на 3 * 3

** 4.5. Конструкции `pass'

   Конструкцията `pass' не прави нищо.  Тя може да бъде използвана,
   когато синтактически се очаква оператор, но програмата изисква
   бездействие.  Например:

       >>> while True:
       ...       pass # Чакай за прекъсване от клавиатурата (Ctrl+C)
       ...

   Това често се използва при създаването на миниатюрни класове:

       >>> class MyEmptyClass:
       ...     pass
       ...

   Друга употреба на `pass' е като тяло на функция или условна
   конструкция, когато работим върху нов код.  Това ни дава възможност
   да продължим да мислим на по-абстрактно ниво.  Конструкцията `pass'
   просто се пренебрегва тихомълком:

       >>> def initlog(*args):
       ...     pass   # Да не забравим да реализираме това!
       ...

** 4.6. Дефиниране на функции

   Можем да създадем функция, която изписва числата на Фибоначи в
   произволна граница:

       >>> def fib(n):    # изписва числата на Фибоначи до n
       ...     """Изписва числата на Фибоначи до n"""
       ...     a, b = 0, 1
       ...     while a < n:
       ...         print a,
       ...         a, b = b, a+b
       ...
       >>> # Сега да извикаме току-що дефинираната функция:
       ... fib(2000)
       0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597

   Ключовата дума `def' въвежда /дефиниция/ на функция.  Тя трябва да
   бъде последвана от името на фукнцията и списък на формалните
   параметри, поставени в скоби.  Конструкциите, образуващи тялото на
   функцията, започват от следващия ред и трябва да бъдат с отстъп.
   
   Първата конструкция от тялото на функцията може да бъде символен
   низ.  Този символен низ представлява документация за функцията, или
   още /документационен символен низ/ (docstring).  (Повече относно
   документационните символни низове може да откриете в раздел
   4.7.6. Документационни символни низове.)  Съществуват инструменти,
   които използват документационните символни низове за да създадат
   автоматично online или печатна документация, или за да позволят на
   потребителя да се разхожда из кода.  Добра практика е да включвате
   документационни символни низове в кода, който пишете, затова се
   опитайте да го превърнете в навик.

   /Изпълнението/ на функция въвежда нова символна таблица,
   предназначена за локалните променливи на функцията.  По-точно,
   всички присвоявания на променливи в една функция запазват
   стойността в локалната символна таблица.  При обръщения към
   променливи се търси първо в локалната символна таблица, после в
   глобалната символна таблица, и накрая в таблицата на вградените
   имена.  По този начин, във функцията не може директно да се присвои
   стойност на глобална променлива (освен ако изрично не се укаже
   конструкцията global), макар че могат да се правят обръщения към
   тях.

   Актуалните параметри (аргументи) на едно извикване на функция се
   въвеждат в локалната символна таблица на извикваната функция, в
   момента, в който тя бива извикана.  Така, аргументите се предават
   чрез /извикване по стойност/ (call by value) (където стойността
   винаги е /указател/ (reference) към обект, а не самата стойност на
   обекта).[*]  Когато една функция извиква друга функция, се създава
   нова локална символна таблица за това извикване.

   [*] В действителност, /извикване по обектен указател/ би било
       по-добро описание, тъй като ако се подаде изменяем обект,
       извикващият би видял всички промени, които извикваният е
       направил по указателя (напр., вмъкнати елементи в списък).

   Дефиницията на функция въвежда името на функцията в текущата
   символна таблица.  Стойността на името на фукнцията има тип, който
   се разпознава от интерпретатора като дефинирана от потребителя
   функция.  Тази стойност може да бъде присвоявана на друго име,
   което после също може да бъде използвано като функция.  Това служи
   като общ механизъм за преименуване:

       >>> fib
       <function fib at 10042ed0>
       >>> f = fib
       >>> f(100)
       0 1 1 2 3 5 8 13 21 34 55 89

   Ако идвате от други езици (напр. Паскал) можете да възразите, че
   `fib' не е функция, а процедура, понеже не връща стойност.  В
   действителност, дори функциите без конструкция `return' връщат
   стойност, макар и твърде безинтересна.  Тази стойност се нарича
   None (това е вградено име).  Обикновено изписването на стойността
   None се подтиска от интерпретатора, ако тя е единствената стойност,
   която ще бъде изведена.  Можете да я видите чрез `print', ако
   наистина държите на това:

       >>> fib(0)
       >>> print fib(0)
       None

   Лесно е да се напише функция, която връща списък от числата на
   Фибоначи, вместо да ги извежда.

       >>> def fib2(n): # връща числата на Фибоначи до n
       ...     """Връща списък, съдържащ числата на Фибоначи до n"""
       ...     result = []
       ...     a, b = 0, 1
       ...     while a < n:
       ...         result.append(a)    # виж по-долу
       ...         a, b = b, a+b
       ...     return result
       ...
       >>> f100 = fib2(100)    # извикай я
       >>> f100                # изведи резултата
       [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]

   Този пример, както обикновено, показва някои нови свойства на
   Питон:

       + Конструкцията `return' връща изпълнението от функцията,
         предавайки стойност.  `return' без израз като аргумент връща
         None.  Когато изпълнението стигне до края на тялото на
         функцията, също се връща None.

       + Конструкцията `result.append(b)' извиква /метод/ на обекта от
         тип списък `result'.  Методът е функция, която „принадлежи“
         на даден обект и се именува ОБЕКТ.ИМЕ_НА_МЕТОД, където
         ИМЕ_НА_МЕТОД е името на метода, дефиниран от типа на обекта.
         Различните типове дефинират различни методи.  Методите на
         различни типове могат да имат еднакви имена, без това да
         поражда двусмисленост.  (Възможно е да дефинирате ваши
         собствени типове обекти и методи, използвайки /класове/, виж
         раздел 9. Класове.)  Методът `append()', показан в този
         пример, е дефиниран за обектите от тип списък.  Той добавя
         нов елемент в края на списъка.  В този пример той е
         еквивалентен на ‘result = result + [b]’, но е по-ефикасен.

** 4.7. Повече за дефинирането на функции

   Освен това е възможно да се дефинират функции с променлив брой
   аргументи.  Съществуват три форми, които могат да бъдат
   комбинирани.

*** 4.7.1. Стойности на аргументи по подразбиране

    Най-полезната форма е да се определи стойност по подразбиране на
    един или повече аргументи.  Това създава функция, която може да
    бъде извиквана с по-малко аргументи, отколкото е дефинирана,
    например:

        def ask_ok(prompt, retries=4, complaint='Да или не, ако обичате!'):
            while True:
                ok = raw_input(prompt)
                if ok in ('д', 'да', 'мда', 'дам', 'ъхъ'):
                    return True
                if ok in ('н', 'не', 'тц'):
                    return False
                retries = retries - 1
                if retries < 0:
                    raise IOError('инат потребител')
                print complaint

    Тази функция може да бъде извикана по няколко начина:

        + подавайки само задължителния аргумент:

          ask_ok('Наистина ли желаете да излезете?')

        + подавайки някой от незадължителните аргументи:

          ask_ok('Да се препокрие ли файла?', 2)

        + или подавайки всички аргументи:

          ask_ok('Да се препокрие ли файла?', 2, 'Айде, де, само да или не!')

    Примерът въвежда и ключовата дума `in'.  Тя служи за проверка дали
    една редица съдържа дадена стойност или не.

    Стойностите по подразбиране се оценяват в момента на дефиниране на
    функцията спрямо обхвата към който принадлежи самата дефиниция,
    така че:

        i = 5

        def f(arg=i):
            print arg

        i = 6
        f()

    ще изведе `5'.

    *Важно предупреждение:* Стойностите по подразбиране се изчисляват
    само веднъж.  Това има значение, когато стойността по подразбиране
    е изменяем обект като списък или речник (dictionary).  Например,
    следващата функция събира аргументите, които ѝ се подават в
    последователни извиквания:

        def f(a, L=[]):
            L.append(a)
            return L

        print f(1)
        print f(2)
        print f(3)

    Това ще отпечата:

        [1]
        [1, 2]
        [1, 2, 3]

    Ако не желаете стойността по подразбиране да бъде споделяна между
    последователните извиквания, можете да напишете функцията по
    следния начин:

        def f(a, L=None):
            if L is None:
                L = []
            L.append(a)
            return L

*** 4.7.2. Аргументи с ключови думи

    Също така, функциите могат да бъдат извиквани чрез аргументи с
    ключови думи във вида `ключова_дума = стойност'.  Например,
    следващата функция:

        def parrot(voltage, state='вкочанен', action='изгърми', type='норвежко синьо'):
            print "-- Този папагал няма да", action,
            print "ако му пуснеш", voltage, "волта."
            print "-- Прекрасна перушина в", type
            print "-- Той е", state, "!"

    може да бъде извиквана по който и да е от следните начини:

        parrot(1000)
        parrot(action = 'БУУУУМ', voltage = 1000000)
        parrot('хиляда', state = 'гушнал букета')
        parrot('милион', 'лишен от живот', 'скочи')

    но следващите извиквания биха били невалидни:

        parrot()                        # липсва задължителен аргумент
        parrot(voltage=5.0, 'dead')     # аргумент с не-ключова дума следва ключова дума
        parrot(110, voltage=220)        # дублирана стойност за аргумент
        parrot(actor='Георги Парцалев') # непозната ключова дума

    Изобщо, списъкът с аргументите може да съдържа всякакви позиционни
    аргументи, следвани от всякакви аргументи с ключови думи, където
    ключовите думи трябва да са избрани измежду имената на формалните
    параметри.  Не е от значение дали даден формален параметър има
    стойност по подразбиране или не.  Не може обаче един аргумент да
    получи стойност повече от веднъж.  Имената на формалните
    параметри, съответни на позиционните аргументи, не могат да бъдат
    използвани като ключови думи в едно и също извикване.  Ето един
    пример, който пропада заради това ограничение:

        >>> def function(a):
        ...     pass
        ...
        >>> function(0, a=0)
        Traceback (most recent call last):
          File "<stdin>", line 1, in ?
        TypeError: function() got multiple values for keyword argument 'a'

    Когато последният формален параметър има формата `**име', той
    получава речник (виж раздел 5.8 „Mapping Types – `dict'“ от Python
    Library Reference), съдържащ всички аргументи с ключови думи,
    които не съответстват на формален параметър.  Това може да бъде
    комбинирано с формален параметър с формата `*име' (описан в
    следващия раздел), който получава комплект (tuple), съдържащ
    позиционните аргументи извън списъка на формалните параметри.
    (`*име' трябва да се яви преди `**име'.)  Например, ако дефинираме
    функция, подобна на тази:

        def cheeseshop(kind, *arguments, **keywords):
            print "-- Do you have any", kind, "?"
            print "-- I'm sorry, we're all out of", kind
            for arg in arguments: print arg
            print "-" * 40
            keys = keywords.keys()
            keys.sort()
            for kw in keys: print kw, ":", keywords[kw]

    Тя може да бъде извикана например така:

        cheeseshop("Limburger", "It's very runny, sir.",
                   "It's really very, VERY runny, sir.",
                   shopkeeper='Michael Palin',
                   client="John Cleese",
                   sketch="Cheese Shop Sketch")

    и разбира се, ще изведе:

        -- Do you have any Limburger ?
        -- I'm sorry, we're all out of Limburger
        It's very runny, sir.
        It's really very, VERY runny, sir.
        ----------------------------------------
        client : John Cleese
        shopkeeper : Michael Palin
        sketch : Cheese Shop Sketch

    Обърнете внимание, че методът `sort()' се изпълнява върху имената
    на аргументите с ключови думи преди извеждането на съдържанието на
    речника с ключови думи.  Ако това не се направи, аргументите ще
    бъдат изведени в недефиниран ред.

*** 4.7.3. Списъци с произволни аргументи

    И накрая, най-рядко използваната възможност е да се укаже, че
    функцията може да бъде извиквана с произволен брой аргументи.
    Тези аргументи ще бъдат увити в комплект (виж раздел
    5.3. „Комплекти и редици“).  Преди произволния брой аргументи
    могат да се явят нула или повече нормални аргументи.

        def write_multiple_items(file, separator, *args):
            file.write(separator.join(args))

*** 4.7.4. Разпакетиране на списъци с аргументи

    Обратната ситуация възниква, когато аргументите вече се намират в
    списък или комплект, но трябва да бъдат разпакетирани за да
    послужат при извикването на функция, изискваща отделни позиционни
    аргументи.  Например, вградената функция `range()' очаква отделни
    аргументи /start/ и /stop/.  Ако не разполагате с тях по отделно,
    напишете извикването на функцията с оператор `*' за да
    разпакетирате аргументите, изваждайки ги от списък или комплект:

        >>> range(3, 6)         # нормално извикване с отделни аргументи
        [3, 4, 5]
        >>> args = [3, 6]
        >>> range(*args)        # извикване с аргументи, разпакетирани от списък
        [3, 4, 5]

    По подобен начин, речниците могат да предоставят аргументи с
    ключови думи чрез оператора `**':

        >>> def parrot(voltage, state='вкочанен', action='изгърми'):
        ...     print "-- Този папагал няма да", action,
        ...     print "ако му пуснеш", voltage, "волта.",
        ...     print "-- Той е", state, "!"
        ...
        >>> d = {"voltage": "четири милиона", "state": "хвърлил топа", "action": "ИЗГЪРМИ"}
        >>> parrot(**d)
        -- Този папагал няма да ИЗГЪРМИ ако му пуснеш четири милиона волта. -- Той е хвърлил топа !

*** 4.7.5. Ламбда-форми

    Поради всеобщо желание, в Питон са добавени няколко свойства,
    които обикновено са присъщи на функционалните езици като Lisp.
    Чрез ключовата дума `lambda' могат да се създават малки анонимни
    функции.  Ето функция, която връща сбора на двата си аргумента:
    `lambda a, b: a+b'.  Ламбда-формите могат да се използват
    навсякъде, където се изискват обекти от тип функция.
    Синтактически, те са ограничени до единичен израз.  Семантически
    те са просто синтактична глезотия (syntactic sugar), заместваща
    нормалните дефиниции на функции.  Както и вложените дефиниции на
    функции, ламбда-формите могат да се обръщат към променливи в
    съдържащия ги обхват:

        >>> def make_incrementor(n):
        ...     return lambda x: x + n
        ...
        >>> f = make_incrementor(42)
        >>> f(0)
        42
        >>> f(1)
        43

*** 4.7.6. Документационни символни низове

    Очертават се конвенции за съдържанието и форматирането на
    документационните символни низове.

    Първият ред винаги трябва да бъде кратко, стегнато резюме на
    предназначението на обекта.  За краткост то не бива явно да
    назовава името на обекта или неговият тип, тъй като тези данни са
    достъпни посредством други способи (с изключение на случаите,
    когато името е глагол, описващ действието на функция).  Този ред
    трябва да започва с главна буква и да завършва с точка.

    Ако има повече редове в документационния символен низ, вторият ред
    трябва да бъде оставен празен, нагледно разделящ резюмето от
    останалото описание.  Следващите редове трябва да представляват
    един или повече абзаци, описващи конвенциите за извикване на
    обекта, страничните му ефекти, и прочие.

    Граматичният анализатор на Питон не премахва отстъпа от
    многоредовите символни низове, така че средствата, които
    обработват документацията следва (по желание) сами да се погрижат
    за това.  За целта се използва следната конвенция.  Първият
    непразен ред /след/ първия ред от символния низ определя размера
    на отстъпа за целия документационен символен низ.  (Не можем
    просто да използваме първия ред, тъй като по принцип в съседство с
    него са отварящите кавички на символния низ, и затова неговият
    отстъп не е очевиден в символния литерал.)  Тогава празното
    пространство, „равностойно“ на този отстъп, се премахва от
    началото на всички редове в символния низ.  Не бива да има редове,
    които са с по-малък отстъп, но ако все пак ги има, цялото им
    начално празно пространство трябва да се премахне.
    Равностойността на празното пространство трябва да се проверява
    след разгръщането на табулациите (обикновено до 8 шпации).

    Ето един пример за многоредов документационен символен низ:

        >>> def my_function():
        ...     """Не прави нищо, но нека да я документираме.
        ...
        ...     Ама не, наистина нищо не прави.
        ...     """
        ...     pass
        ...
        >>> print my_function.__doc__
        Не прави нищо, но нека да я документираме.
        
            Ама не, наистина нищо не прави.

** 4.8. Интермедия: стил на кодиране

   Понеже ви предстои да пишете по-дълги и сложни фрагменти на Питон,
   дойде време да поговорим за стила на /кодиране/.  Повечето езици
   могат да бъдат писани (или по-точно, /форматирани/) според различни
   стилове.  Някои от тях са по-четливи от други.  Да направите кода
   си лесен за четене от другите винаги е добра идея, а хубавият стил
   на кодиране страшно помага за това.

   В Питон, PEP 8 се очерта като ръководство по стил, спазвано от
   повечето проекти.  То насърчава стил, който е много четивен и
   приятен за окото.  Всеки разработчик на Питон следва да го прочете
   в някакъв момент.  Ето ги неговите най-важни точки, подбрани за
   вас:

       + Използвайте отстъп с 4 шпации, без никакви табулации.

       + 4 шпации са добър компромис между малък отстъп (позволява
         повече нива на влагане) и голям отстъп (по-лесен за четене).
         Табулациите вкарват объркване и е най-добре без тях.

       + Пренасяйте редовете така, че да не надвишават 79 символа.

       + Това от една страна помага на потребителите с малки дисплеи,
         а от друга – дава възможност да се разполагат няколко файла
         един до друг върху по-големи дисплеи.

       + Използвайте празни редове за да отделите функциите и
         класовете, както и по-големите блокове код в рамките на
         функциите.

       + Когато е възможно, поставяйте коментарите на самостоятелен
         ред.

       + Използвайте документационни символни низове.

       + Използвайте шпации около операторите и след запетаите, но не
         и непосредствено в конструкциите със скоби: `a = f(1, 2) +
         g(3, 4)'.

       + Именувайте класовете и функциите си консистентно.
         Конвенцията изисква да използвате `CamelCase' за имената на
         класовете и `малки_букви_с_подчертаване' за функциите и
         методите.  Винаги използвайте `self' като име на първия
         аргумент на методите (виж раздел 9.3. „Пръв поглед върху
         класовете“ за повече информация относно класовете и методите).

       + Не използвайте гиздави кодирания ако кодът ви е предназначен
         за употреба в международна среда.  Обикновеното ASCII винаги
         върши работа.
