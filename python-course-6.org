* 6. Модули

  Ако излезете от интерпретатора на Питон и влезете отново,
  дефинициите които сте направили (функции и променливи) се губят.
  Следователно, ако желаете да напишете малко по-дълга програма,
  по-добре е да използвате текстов редактор, за да подготвите входа за
  интерпретатора и да го стартирате с този файл като вход.  Това е
  известно като създаване на /скрипт/.  Когато програмата ви порастне,
  може би ще пожелаете да я разделите на няколко файла за по-лесна
  поддръжка.  Също така, може да пожелаете да използвате написана от
  вас полезна функция в няколко програми, без да копирате дефиницията
  и във всяка една отделна програма.

  За да поддържа тези неща, Питон разполага с начин да поставяте
  дефинициите във файл и да ги използвате в скрипт или в интерактивна
  инстанция на интерпретатора.  Такъв файл се нарича /модул/;
  дефинициите от даден модул могат да бъдат импортирани в други модули
  или в главния модул (сборът от променливи, към които имате достъп в
  даден скрипт, изпълняващ се на най-високо ниво и в режим на
  калкулатор).


  Модулът е файл, съдържащ дефиниции и конструкции на Питон.
  Файловото име е името на модула с добавен суфикс `.py'.  В рамките
  на един модул, името му (като символен низ) е достъпно като стойност
  на глобалната променлива `__name__'.  Например, използвайте любимия
  си текстов редактор за да създадете файл, наречен `fibo.py' в
  текущата директория със следното съдържание:

      # Модул за числата на Фибоначи

      def fib(n):    # извежда числата на Фибоначи до n
          a, b = 0, 1
          while b < n:
              print b,
              a, b = b, a+b

      def fib2(n): # връща числата на Фибоначи до n
          result = []
          a, b = 0, 1
          while b < n:
              result.append(b)
              a, b = b, a+b
          return result

  Сега влезте в интерпретатора на Питон и импортирайте този модул със
  следната команда:

      >>> import fibo

  Така имената на функциите, дефинирани във `fibo', не се внасят
  направо в текущата символна таблица; внася се само името на модула
  `fibo'.  Чрез името на модула получавате достъп до функциите:

      >>> fibo.fib(1000)
      1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
      >>> fibo.fib2(100)
      [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
      >>> fibo.__name__
      'fibo'

  Ако възнамерявате често да използвате дадена функция, можете да я
  присвоите на локално име:

      >>> fib = fibo.fib
      >>> fib(500)
      1 1 2 3 5 8 13 21 34 55 89 144 233 377

** 6.1. Повече за модулите
   
   Освен дефиниции на функции, модулите могат да съдържат и изпълними
   конструкции, които са предназначени да инициализират модула.  Те се
   изпълняват само първия път, когато модулът е импортиран някъде.

   [*] В действителност, дефинициите на функции също са „конструкции“,
      които се „изпълняват“.  Изпълнението на една дефиниция на
      функция внася името на функцията в глобалната символна таблица
      на модула.

   Всеки модул притежава своя собствена символна таблица, която се
   използва като глобална символна таблица от всички функции,
   дефинирани в модула.  По този начин, авторът на модула може да
   използва глобални променливи в модула, без да се притеснява от
   евентуални конфликти с глобалните променливи на потребителя.  От
   друга страна, ако знаете какво правите, можете да се доберете до
   глобалните променливи на даден модул със същата нотация, използвана
   и за обръщение към неговите функции —
   `име_на_модул.име_на_елемент'.

   Модулите могат да импортират други модули.  Обичайно е (но не
   задължително) всички конструкции `import' да се разполагат в
   началото на модула (или скрипта).  Имената на импортираните модули
   се разполагат в глобалната символна таблица на импортиращия модул.

   Съществува вариант на конструкцията `import', която импортира
   имената от даден модул направо в символната таблица на импортиращия
   модул.  Например:

       >>> from fibo import fib, fib2
       >>> fib(500)
       1 1 2 3 5 8 13 21 34 55 89 144 233 377

   Това не внася името на модула, от който са импортирани имената, в
   локалната символна таблица (така че в този пример името `fibo' не е
   дефинирано).

   Дори съществува вариант, чрез който се импортират всички имена,
   които даден модул дефинира:

       >>> from fibo import *
       >>> fib(500)
       1 1 2 3 5 8 13 21 34 55 89 144 233 377

   Така се импортират всички имена, с изключение на започващите с
   долна черта (_).

   Имайте предвид, че като цяло не се гледа с добро око тази практика
   да се импортира `*' от даден модул или пакет, тъй като това често
   се отразява неблагоприятно на четливостта на кода.  Все пак можете
   да използвате този подход в интерактивните сесии за да си спестите
   писане.

   *Забележка*: От съображения за ефективност, всеки модул бива
                импортиран само веднъж в дадена сесия на
                интерпретатора.  Следователно, ако променяте модулите
                си, ще се наложи да рестартирате интерпретатора.  Друг
                вариант –- в случай, че искате да тествате само един
                модул интерактивно -- е да използвате функцията
                `reload()', т.е. `reload(МОДУЛ)'.

*** 6.1.1. Изпълняване на модулите като скриптове

    Когато изпълните модул на Питон с командата:

        python fibo.py <АРГУМЕНТИ>

    тогава кодът на модула ще бъде изпълнен така, сякаш сте го
    импортирали.  Единствената разлика е, че глобалната променливата
    `__name__' ще е установена на стойността "__main__".  Това
    означава, че като добавите този код на края на вашия модул:

        if __name__ == "__main__":
            import sys
            fib(int(sys.argv[1]))

    можете да направите файла изпълним като скрипт, освен като
    импортируем модул.  Това е така, понеже кодът който приема
    аргументи от командния ред се изпълнява само когато модулът бива
    изпълнен като „главен“ (main) файл:

        $ python fibo.py 50
        1 1 2 3 5 8 13 21 34

    Ако модулът бъде импортиран, тогава този код не се изпълнява:

        >>> import fibo
        >>>

    Често този похват се използва за да се предостави удобен
    потребителски интерфейс към даден модул или пък за целите на
    тестването (модулът се стартира като скрипт, изпълняващ комплект
    от тестови сценарии).

*** 6.1.2. Път за търсене на модули

    Когато се импортира модул с име spam, интерпретаторът търси файл с
    име `spam.py' в текущата директория.  А сетне в списък от
    директории, определен от променливата `$PYTHONPATH' от
    обкръжението (environment).  Тя има същия синтаксис, както и
    променливата `$PATH' на обвивката, сиреч списък от имена на
    директории.  Когато `$PYTHONPATH' не е установена, или когато
    файлът не е открит там, търсенето продължава в път по
    подразбиране, който зависи от инсталацията; в UNIX, това
    обикновено е `.:/usr/local/lib/python'.

    Всъщност модулите се търсят в списък от директории, даден от
    променливата `sys.path', която се инициализира с директорията,
    съдържаща входния скрипт (или текущата директория), `$PYTHONPATH'
    и стойността по подразбиране, зависима от инсталацията.  Това
    позволява на програми на Питон, които знаят какво вършат, да
    модифицират или подменят пътя за търсене на модули.  Имайте
    предвид, че понеже директорията, съдържаща скрипта, се намира в
    пътя за търсене на модули, е важно скриптът да не носи същото име
    като на някой от стандартните модули, тъй като в този случай Питон
    ще опита да зареди скрипта като модул в момента в който този модул
    бъде импорторан.  Това в общия случай ще бъде грешка.  За повече
    информация, вижте раздела „Стандартни модули“ по-долу.

*** 6.1.3. „Компилирани“ файлове на Питон

    Ако съществува файл, наречен `spam.pyc' в директория където се
    намира `spam.py', тогава се приема, че той вече съдържа
    „компилирана до байткод“ версия на модула `spam'.  Целта е да се
    ускори времето за стартиране на кратки програми, използващи
    множество стандартни модули.  Времето на последната промяна на
    версията на `spam.py', използвана за да се създаде съответния файл
    `spam.pyc', е записано в `spam.pyc'.  Ако времената не съвпадат,
    `.pyc'-файлът се игнорира.

    Обикновено няма нужда да правите нищо, за да създадете файла
    `spam.pyc'.  Всеки път, когато `spam.py' бъде компилиран успешно,
    се прави опит да се запише компилираната версия в `spam.pyc'.  Не
    е грешка, ако този опит се провали.  Ако поради някаква причина
    файлът не е напълно записан, получилият се файл `spam.pyc' ще бъде
    разпознат като невалиден и, така, игнориран по-късно.
    Съдържанието на файла `spam.pyc' е независимо от платформата, така
    че директория с модули на Питон може да бъде споделяна от машини с
    различни архитектури.

    Няколко съвета за специалистите:

    - Когато интерпретаторът на Питон е извикан с флага `-O', тогава
      се създава оптимизиран код, който се запазва в `.pyo'-файлове.
      Засега оптимизаторът не прави кой знае какво; той само премахва
      конструкциите `assert'.  Когато е използван флагът `-O', се
      оптимизира всичкия байткод; `.pyc' файловете се игнорират и
      `.py' файловете се компилират до оптимизиран байткод.

    - Подаването на два флага `-O' към интерпретатора на Питон (`-OO')
      ще накара компилатора на байткод да извърши оптимизации, които
      могат в някои редки случаи да доведат до неправилно
      функциониращи програми.  Засега от байткода само се премахват
      документационните символни низове `__doc__', което довежда до
      по-компактни `.pyo'-файлове.  Тъй като някои програми могат да
      разчитат на наличието им, трябва да използвате тази опция само
      ако знаете какво правите.

    - Програмата въобще не върви по-бързо, когато се чете от `.pyc'
      или `.pyo'-файл, вместо когато се чете от `.py'-файл;
      единственото по-бързо нещо при `.pyc' или `.pyo'-файловете е
      скоростта, с която се зареждат.

    - Когато даден скрипт се стартира с подаване на името му от
      командния ред, байткодът за този скрипт никога не се записва в
      `.pyc' или `.pyo'-файл.  Следователно, времето за стартиране на
      един скрипт може да бъде намалено като се премести повечето от
      кода му в модул, оставяйки само малък стартиращ скрипт, който
      импортира този модул.  Също така е възможно от командния ред да
      се посочи направо `.pyc' или `.pyo'-файл.

    - Възможно е да съществува файл `spam.pyc' (или `spam.pyo', когато
      е използван `-O'), без в същата директория да съществува
      съответния файл `spam.py'.  Това може да служи за
      разпространение на библиотека от код на Питон във форма,
      относително трудна за дизасемблиране (reverse engineer).

    - Модулът compileall може да създава `.pyc'-файлове (или `.pyo'
      файлове, когато е използван `-O') за всички модули в дадена
      директория.

** 6.2. Стандартни модули

  Питон идва с библиотека от стандартни модули, описана в отделен
  документ, Python Library Reference („Library Reference“ от тук
  нататък).  Някои модули са вградени в интерпретатора; те осигуряват
  достъп до операции, които не са част от същинския език, но са така
  или иначе вградени, дали заради производителност или за да осигурят
  достъп до примитивите на операционната система, като системни
  извиквания, например.  Множеството от такива модули е въпрос на
  конфигурационен избор. Например, модулът `winreg' се обезпечава само
  върху системите Windows.  Един особен модул заслужава малко повече
  внимание: `sys', който е вграден във всеки интерпретатор на Питон.
  Променливите `sys.ps1' и `sys.ps2' дефинират символните низове,
  използвани като вторични и първични промптове:

      >>> import sys
      >>> sys.ps1
      '>>> '
      >>> sys.ps2
      '... '
      >>> sys.ps1 = 'C> '
      C> print 'Блях!'
      Блях!
      C>

  Тези две променливи са дефинирани само ако интерпретаторът е в
  интерактивен режим.

  Променливата `sys.path' е списък от символни низове, който определя
  пътя за търсене на модули от интерпретатора.  Той се инициализира с
  пътя по подразбиране, взет от променливата `$PYTHONPATH' на
  обкръжението, или от вградена стойност по подразбиране, в случай, че
  `$PYTHONPATH' не е дефинирана.  Можете да я променяте посредством
  обикновените операции върху списък, например:

      >>> import sys
      >>> sys.path.append('/ufs/guido/lib/python')

** 6.3. Функцията `dir()'

   Вградената функция dir() се използва, за да се открие какви имена
   са дефинирани от даден модул.  Тя връща сортиран списък от символни
   низове.

       >>> import fibo, sys
       >>> dir(fibo)
       ['__name__', 'fib', 'fib2']
       >>> dir(sys)
       ['__displayhook__', '__doc__', '__excepthook__', '__name__', '__stderr__',
        '__stdin__', '__stdout__', '_getframe', 'api_version', 'argv',
        'builtin_module_names', 'byteorder', 'callstats', 'copyright',
        'displayhook', 'exc_clear', 'exc_info', 'exc_type', 'excepthook',
        'exec_prefix', 'executable', 'exit', 'getdefaultencoding', 'getdlopenflags',
        'getrecursionlimit', 'getrefcount', 'hexversion', 'maxint', 'maxunicode',
        'meta_path', 'modules', 'path', 'path_hooks', 'path_importer_cache',
        'platform', 'prefix', 'ps1', 'ps2', 'setcheckinterval', 'setdlopenflags',
        'setprofile', 'setrecursionlimit', 'settrace', 'stderr', 'stdin', 'stdout',
        'version', 'version_info', 'warnoptions']

   Извикана без аргументи, `dir()' връща списък на имената, които
   понастоящем сте дефинирали:

       >>> a = [1, 2, 3, 4, 5]
       >>> import fibo
       >>> fib = fibo.fib
       >>> dir()
       ['__builtins__', '__doc__', '__file__', '__name__', 'a', 'fib', 'fibo', 'sys']

   Забележете, че функцията връща списък на всички видове имена:
   променливи, модули, функции, и прочие.

   Функцията `dir()' не връща списък на имената на вградените функции
   и променливи.  Ако желаете техния списък, те са дефинирани в
   стандартния модул `__builtin__':

       >>> import __builtin__
       >>> dir(__builtin__)
       ['ArithmeticError', 'AssertionError', 'AttributeError', 'DeprecationWarning',
        'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False',
        'FloatingPointError', 'FutureWarning', 'IOError', 'ImportError',
        'IndentationError', 'IndexError', 'KeyError', 'KeyboardInterrupt',
        'LookupError', 'MemoryError', 'NameError', 'None', 'NotImplemented',
        'NotImplementedError', 'OSError', 'OverflowError',
        'PendingDeprecationWarning', 'ReferenceError', 'RuntimeError',
        'RuntimeWarning', 'StandardError', 'StopIteration', 'SyntaxError',
        'SyntaxWarning', 'SystemError', 'SystemExit', 'TabError', 'True',
        'TypeError', 'UnboundLocalError', 'UnicodeDecodeError',
        'UnicodeEncodeError', 'UnicodeError', 'UnicodeTranslateError',
        'UserWarning', 'ValueError', 'Warning', 'WindowsError',
        'ZeroDivisionError', '_', '__debug__', '__doc__', '__import__',
        '__name__', 'abs', 'apply', 'basestring', 'bool', 'buffer',
        'callable', 'chr', 'classmethod', 'cmp', 'coerce', 'compile',
        'complex', 'copyright', 'credits', 'delattr', 'dict', 'dir', 'divmod',
        'enumerate', 'eval', 'execfile', 'exit', 'file', 'filter', 'float',
        'frozenset', 'getattr', 'globals', 'hasattr', 'hash', 'help', 'hex',
        'id', 'input', 'int', 'intern', 'isinstance', 'issubclass', 'iter',
        'len', 'license', 'list', 'locals', 'long', 'map', 'max', 'min',
        'object', 'oct', 'open', 'ord', 'pow', 'property', 'quit', 'range',
        'raw_input', 'reduce', 'reload', 'repr', 'reversed', 'round', 'set',
        'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super',
        'tuple', 'type', 'unichr', 'unicode', 'vars', 'xrange', 'zip']

** 6.4. Пакети

   Пакетите са начинът на Питон за структуриране на имената на
   модулите, използвайки „точкувани имена на модули“.  Например, името
   на модул `A.B' обозначава подмодул с име `B' в пакет с име `A'.
   Точно както използването на модули предпазва авторите на различни
   модули от безпокойството помежду им относно имената на глобалните
   променливи, така използването на точкувани имена на модули
   предпазва авторите на многомодулни пакети като NumPy или Python
   Imaging Library от безпокойството помежду им относно имената на
   модулите.

   Да предположим, че искате да проектирате колекция от модули
   (“пакет”) за обща обработка на звукови файлове и звукови данни.
   Съществуват много различни звукови файлови формати (обикновено
   разпознавани по разширението им, например `.wav', `.aiff', `.au'),
   така че може да се наложи да създадете и поддържате растяща
   колекция от модули за конвертиране между разнообразните файлови
   формати.  Също така, съществуват много различни операции, които
   може би ще желаете да изпълнявате върху звуковите данни (например
   миксиране, добавяне на ехо, прилагане на еквалайзерна функция,
   създаване на изкуствен стерео-ефект), така че като добавка ще
   пишете безкраен поток от модули за прилагане на тези операции.  Ето
   една възможна структура на Вашия пакет (изразен в термините на
   йерархична файлова система):

   sound/                       Пакет от най-високо ниво
      __init__.py               Инициализация на звуковия пакет
      formats/                  Подпакет за конвертиране на файлови формати
              __init__.py
              wavread.py
              wavwrite.py
              aiffread.py
              aiffwrite.py
              auread.py
              auwrite.py
              ...
      effects/                  Подпакет за звукови ефекти
              __init__.py
              echo.py
              surround.py
              reverse.py
              ...
      filters/                  Подпакет за филтри
              __init__.py
              equalizer.py
              vocoder.py
              karaoke.py
              ...

   Когато импортирате пакета, Питон преглежда директориите, посочени в
   `sys.path', търсейки поддиректорията на пакета.

   Файловете `__init__.py' са необходими за да накарат Питон да се
   отнася към директориите като съдържащи пакети.  Това е направено за
   да се предотвратят случите, когато директории с общоприето име,
   например `string', случайно скриват валидни модули, които се
   появяват по-късно в пътя за търсене на модули.  В най-простия
   случай, `__init__.py' може да бъде просто празен файл, но той може
   и да изпълнява инициализиращ код за пакета, или да установява
   променливата `__all__', описана по-долу.

   Потребителите на пакета могат да импортират отделни модули от
   пакета, например:

       import sound.effects.echo

   Така се зарежда подмодула sound.effects.echo.  Към него трябва да
   се обръщате с пълното му име.

       sound.effects.echo.echofilter(input, output, delay=0.7, atten=4)
   
   Друг начин за импортиране на този подмодул е:

       from sound.effects import echo

   Зареден по този начин, подмодулът `echo' е достъпен без префикса на
   пакета му, така че може да бъде използван както следва:

       echo.echofilter(input, output, delay=0.7, atten=4)

   Още един вариант пък е да импортираме на желаната функция или
   променлива непосредствено:

       from sound.effects.echo import echofilter

   Още веднъж, така се зарежда подмодула `echo', но по такъв начин, че
   неговата функция `echofilter()' е непосредствено достъпна:

       echofilter(input, output, delay=0.7, atten=4)

   Забележете, че когато се използва `from ПАКЕТ import ЕЛЕМЕНТ',
   елементът може да бъде или подмодул (или подпакет) на пакета, или
   някакво друго дефинирано в пакета име, като функция, клас или
   променлива.  Конструкцията `import' първо проверява дали елемента е
   дефиниран в пакета; ако не е, приема, че е модул и пробва да го
   зареди.  Ако не успее да го открие, се предизвиква изключението
   `ImportError'.

   Обратно, когато се използва синтаксис подобен на `import
   ЕЛЕМЕНТ.ПОДЕЛЕМЕНТ.ПОДПОДЕЛЕМЕНТ', всеки елемент, освен последния,
   трябва да бъде пакет.  Последният елемент може да бъде модул или
   пакет, но не може да бъде клас, функция или променлива, дефинирани
   в предходния елемент.

*** 6.4.1. Импортиране на * от пакет

    Какво се случва, когато потребителят напише `from sound.effects
    import *'?  В идеалния случай, бихме се надявали, че така по
    някакъв начин се излиза във файловата система, откриват се
    наличните в пакета модули, и всички те се импортират.  Това би
    могло да отнеме много време и импортирането на подмодулите може да
    донесе странични ефекти, които би трябвало да се случат само
    когато подмодулът е импортиран изрично.

    Единственото решение е авторът на пакета да даде изричен индекс на
    пакета.  Конструкцията `import' използва следната конвенция: ако
    кодът във файла `__init__.py' на даден пакет дефинира списък с име
    `__all__', се приема че той представлява списък с имената на
    модулите, които трябва да бъдат импортирани, когато се срещне
    `from ПАКЕТ import *'.  Авторът на пакета носи отговорността да
    държи този списък актуален, когато се издава нова версия на
    пакета.  Авторите на пакети могат също така да решат, че няма да
    поддържат този списък, ако не виждат смисъл за импротиране на * от
    техния пакет.  Например, файлът `sounds/effects/__init__.py' би
    могъл да съдържа следния код:

        __all__ = ["echo", "surround", "reverse"]

    Това би означавало, че `from sound.effects import *' би импортирал
    трите посочени подмодула от пакета `sound'.

    Ако `__all__' не е дефиниран, операторът `from sound.effects
    import *' /не/ импортира всички подмодули на пакета sound.effects
    в текущото пространство на имената (namespace); той само осигурява
    импортирането на пакета `sound.effects' (стартирайки неговия
    инициализиращ код, `__init__.py', ако е възможно) и после
    импортира имената, които са дефинирани в пакета.  Това включва
    всички имена, дефинирани (както и всички изрично заредени
    подмодули) от `__init__.py'.  Също така, това включва всякакви
    подмодули на пакета, които са били изрично заредени от предишни
    импортиращи оператори.  Да разгледаме следния код:

        import sound.effects.echo
        import sound.effects.surround
        from sound.effects import *

    В този пример, модулите `echo' и `surround' се импортират в
    текущото пространство на имената, защото са дефинирани в пакета
    `sound.effects' по времето, когато се изпълнява конструкцията
    `from...import'.  (Това работи и когато е дефинирана `__all__'.)

    Въпреки, че когато използвате `import *' някои модули са
    проектирани да експортират само имена, които следват определени
    правила, все пак импортирането на * се счита за лоша практика в
    производствен код.

    Помнете, че няма нищо лошо в това да използвате `from ПАКЕТ import
    КОНКРЕТЕН_ПОДМОДУЛ'!  В действителност това е препоръчителният
    запис, освен ако импортиращият модул не трябва да използва
    подмодули със същото име, но от други пакети.

*** 6.4.2. Вътрешнопакетни обръщения

    Подмодулите често имат нужда да се обръщат един към друг.
    Например, модулът `surround' може да използва модула `echo'.  В
    действителност, подобни обръщения са толкова обичайни, че
    конструкцията `import' първо търси в съдържащия пакет, преди да
    прегледа стандартния път за търсене.  Така, модулът `surround'
    може просто да използва `import echo' или `from echo import
    echofilter'.  Ако импортираният модул не е открит в текущия пакет
    (пакетът, на който текущия модул е подмодул), конструкцията
    `import' търси за модул с даденото име от най-високо ниво.

    Когато пакетите са структурирани в подпакети (както пакетът
    `sound' в нашия пример), можете да използвате абсолютното име на
    подпакета.  Например, ако модулът `sound.filters.vocoder' трябва
    да използва модула `echo' от пакета `sound.effects', той може да
    използва `from sound.effects import echo'.

    От Питон 2.5 нататък, в добавка към имплицитните относителни
    импорти, описани по-горе, можете да пишете и експлицитни релативни
    импорти чрез формата на конструкцията `import' `from МОДУЛ import
    ИМЕ'.  Тези експлицитни относителни импорти използват водещи точки
    за да означат текущия или родителския пакет, спрямо който се
    отнася относителния импорт.  От модула `surround', например,
    можете да използвате:

    from . import echo
    from .. import formats
    from ..filters import equalizer

    Имайте предвид, че както експлицитните, така и имплицитните
    относителни импорти се основават на името на текущия модул.  Тъй
    като името на главния модул е винаги `"__main__"', модулите
    предназначени да бъдат използвани като главни модули в дадено
    приложение на Питон следва винаги да използват абсолютни импорти.

*** 6.4.3. Пакети в няколко директории

    Пакетите поддържат още един специален атрибут –– `__path'.  Той се
    инициализира като списък, съдържащ името на директорията, в която
    стои файла `__init__.py' на текущия пакет.  Тази инициализация се
    случва още преди кодът в този файл да бъде изпълнен.  Променливата
    `__path' може да бъде променяна.  Промяната ѝ се отразява върху
    всяко следващо търсене за модули и подпакети, съдържащи се в този
    пакет.

    Макар че обикновено тази възможност не е необходима, тя може да
    бъде използвана за да се разшири набора от модули, намиращи се в
    даден пакет.
