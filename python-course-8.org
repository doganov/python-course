* 8. Грешки и изключения

  Досега не обръщахме много внимание на съобщенията за грешки, но може
  би сте видели някои от тях, ако сте опитвали примерите. Съществуват
  (поне) два различни вида грешки: /синтактични грешки/ (syntax
  errors) и /изключения/ (exceptions).

** 8.1. Синтактични грешки

   Синтактичните грешки, познати още като граматични грешки, са може
   би най-честият вид проблеми, които срещате, докато все още
   изучавате Питон:

       >>> while True print 'Hello world'
         File "<stdin>", line 1, in ?
           while True print 'Hello world'
                   ^
       SyntaxError: invalid syntax

   Граматичният анализатор повтаря засегнатия ред и изобрзява малка
   стрелка, сочеща към най-ранната точка в реда, където е открита
   грешката.  Грешката е причинена от (или поне открита до) знака,
   /предшестващ/ стрелката – в примера, грешката е открита в ключовата
   дума `print', тъй като преди нея липсват двете точки (‘:’).
   Изведени са файловото име и номера на реда, така че да знаете къде
   да погледнете в случай, че изхода идва от скрипт.

** 8.2. Изключения

   Дори когато даден оператор или израз е синтактически верен, той
   може да предизвика грешка в момента, в който се направи опит да
   бъде изпълнен.  Грешките, открити по време на изпълнение се наричат
   изключения и не са безусловно фатални: скоро ще разберете как да ги
   управлявате в програмите си на Питон.  Повечето изключения не се
   обработват от програмите, така че резултатът се показва в съобщения
   за грешка:

       >>> 10 * (1/0)
       Traceback (most recent call last):
         File "<stdin>", line 1, in ?
       ZeroDivisionError: integer division or modulo by zero
       >>> 4 + spam*3
       Traceback (most recent call last):
         File "<stdin>", line 1, in ?
       NameError: name 'spam' is not defined
       >>> '2' + 2
       Traceback (most recent call last):
         File "<stdin>", line 1, in ?
       TypeError: cannot concatenate 'str' and 'int' objects

   Последният ред от съобщението за грешка посочва какво се е случило.
   Изключенията биват от различен тип, и типът е изведен като част от
   съобщението: типовете в примера са `ZeroDivisionError', `NameError'
   и `TypeError'.  Символният низ, изведен като тип на изключението, е
   вграденото име на появилото се изключение.  Това е вярно за всички
   вградени изключения, но не е непременно вярно за дефинираните от
   потребителя изключения (макар че е една полезна конвенция).
   Стандартните имена на изключения са вградени идентификатори (не са
   запазени ключови думи).

   Останалата част от реда е подробност, чието тълкуване зависи от
   типа на изключението; нейното значение е зависимо от типа на
   изкючението.

   Предходната част от съобщението за грешка показва контекста, в
   който се е случило изключението, във формата на обратно трасиране
   на стека.  Като цяло тя съдържа обратно трасиране на стека,
   изброявайки редовете от изходния код; тя обаче няма да покаже
   редовете, прочетени от стандартния вход.

   `Python Library Reference' съдържа списък на вградените изключения
   и техните значения.

** 8.3. Обработка на изключения

   Възможно е да пишете програми, които да обработват избрани
   изключения.  Вижте следващия пример, който подканя потребителя за
   вход, докато не въведе валидно цяло число, но позволява на
   потребителя да прекъсне програмата (чрез Control-C или каквото там
   поддържа операционната система).  Забележете, че причиненото от
   потребителя прекъсване се сигнализира чрез предизвикването на
   изключение `KeyboardInterrupt'.

       >>> while True:
       ...     try:
       ...         x = int(raw_input("Please enter a number: "))
       ...         break
       ...     except ValueError:
       ...         print "Oops!  That was no valid number.  Try again..."
       ...

   Конструкцията `try' работи както следва.

       - Първо се изпълнява /`try'-клаузата/ (конструкциите между
         ключовите думи `try' и `except').

       – Ако не възникне изключение, /`except'-клаузата/ се пропуска и
         изпълнението на конструкцията `try' приключва.

       – Ако възникне изключение по време на изпълнението на
         `try'-клаузата, останалата част от клаузата се пропуска.
         Тогава ако неговият тип съвпада с изключението, назовано след
         ключовата дума `except', останалата част от `try'-клаузата се
         пропуска, клаузата `except' се изпълнява, и после
         изпълнението продължава след конструкцията `try'.

       – Ако възникне изключение, което не съвпада с изключението,
         назовано в `except'-клаузата, то се подава на по-външните
         конструкции `try'; ако не се намери кой да го обработи, това
         е /необработено изключение/ и изпълнението спира със
         съобщение подобно на показаните по-горе.

   Една конструкция `try' може да притежава повече от една
   `except'-клауза, за да определи различни групи код за обработка на
   различните изключения.  Най-много една от групите код за обработка
   ще се изпълни.  Групите за обработка могат да обработват само
   изключенията, които са се появили в съответната `try'-клауза, но не
   в другите групи за обработка от същата конструкция `try'.  Една
   `except'-клауза може да назове няколко изключения като разделен със
   запетаи комплект, например:

       ... except (RuntimeError, TypeError, NameError):
       ...     pass

   Последната `except' клауза може да пропусне имената на
   изключенията, за да важи за всички.  Използвайте това с крайна
   предпазливост, тъй като по този начин е лесно да маскирате реална
   програмна грешка!  Можете да го използвате също за да изведете
   съобщение за грешка и после отново да предизвикате изключението
   (давайки възможност на извикващия код също да обработи
   изключението):

       import sys

       try:
           f = open('myfile.txt')
           s = f.readline()
           i = int(s.strip())
       except IOError as (errno, strerror):
           print "I/O error({0}): {1}".format(errno, strerror)
       except ValueError:
           print "Could not convert data to an integer."
       except:
           print "Unexpected error:", sys.exc_info()[0]
           raise

   Конструкцията `try ... except' притежава една незадължителна
   `else'-клауза, която (ако я има) трябва да е поставена след всички
   `except'-клаузи.  Използва се за код, който трябва да се изпълни
   ако `try'-клаузата не предизвика изключение.  Например:

       for arg in sys.argv[1:]:
           try:
               f = open(arg, 'r')
           except IOError:
               print 'cannot open', arg
           else:
               print arg, 'has', len(f.readlines()), 'lines'
               f.close()

   По-добре е да използвате `else'-клауза, отколкото да добавяте
   допълнителен код към `try'-клаузата.  Така избягвате случайното
   прихващане на изключение, което не е предизвикано от кода, защитен
   в констукцията `try ... except'.

   Когато възникне изключение, то може да притежава допълнителна
   стойност, известна още като /аргумент/ на изключението.  Наличието
   и типът на аргумента зависят от типа на изключението.

   Клаузата `except' може да укаже една променлива след името (или
   комплекта от имена) на изключението.  Променливата бива свързана
   инстанцията на изключението, чиито аргументи пък са поставени в
   `ИНСТАНЦИЯ.args'.  За удобство, инстанцията на изключението
   дефинира метода `__str__()', така че аргументите се извеждат
   директно на екрана без да има нужда да се реферира атрибута
   `.args'.

   Също така би могло предварително да се създаде инстанция на
   изключение, така че по желание да се добавят допълнителни атрибути
   към нея преди да бъде предизвикано самото изключение.

       >>> try:
       ...    raise Exception('spam', 'eggs')
       ... except Exception as inst:
       ...    print type(inst)     # инстанцията на изключението
       ...    print inst.args      # аргументите, запазени в .args
       ...    print inst           # __str__ позволява на аргументите да се изведат директно
       ...    x, y = inst          # __getitem__ позволява аргументите да се разпакетират директно
       ...    print 'x =', x
       ...    print 'y =', y
       ...
       <type 'exceptions.Exception'>
       ('spam', 'eggs')
       ('spam', 'eggs')
       x = spam
       y = eggs

   Ако дадено изключение притежава аргумент, той е изведен в
   последната част („подробност“) на съобщението за необработени
   изключения.

   Групата код за обработка на изключение обработва изключенията не
   само когато се появят непосредствено в `try'-клаузата, но също така
   и ако се появят вътре в (дори непряко) извикваните функции в
   `try'-клаузата.  Например:

       >>> def this_fails():
       ...     x = 1/0
       ...
       >>> try:
       ...     this_fails()
       ... except ZeroDivisionError as detail:
       ...     print 'Handling run-time error:', detail
       ...
       Handling run-time error: integer division or modulo by zero

** 8.4. Предизвикване на изключения

   Конструкцията `raise' позволява на програмиста да направи така, че
   да се появи определено изключение.  Например:

       >>> raise NameError('HiThere')
       Traceback (most recent call last):
         File "<stdin>", line 1, in ?
       NameError: HiThere

   Аргументът на `raise' е класът или инстанцията на изключението,
   което трябва да бъде предизвикано.  Съществува един остарял
   алтернативен синтаксис, който получава два разделени аргументи –
   като име на клас и конструктор.  По-горният пример може да бъде
   написан като `raise NameError, 'HiThere'.  Тъй като навремето това
   беше единственият наличен синтаксис, тази остаряла форма
   преобладава в стария код.

   За случаите, когато просто имате нужда да проверите дали е било
   предизвикано изключение, но нямате намерение да го обработвате,
   съществува една по-проста форма на конструкцията `raise', която
   позволява да хвърлите наново дадено изключение:

       >>> try:
       ...     raise NameError('HiThere')
       ... except NameError:
       ...     print 'An exception flew by!'
       ...     raise
       ...
       An exception flew by!
       Traceback (most recent call last):
         File "<stdin>", line 2, in ?
       NameError: HiThere

** 8.5. Дефинирани от потребителя изключения

