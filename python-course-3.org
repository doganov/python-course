* 3. Неформално въведение в Питон

  + Коментарите в Питон започват със знак за диез, ‘#’, и продължават
    до края на физическия ред.

  + Коментар може да се появи в началото на реда или след празно
    пространство или код, но не и в рамките на символен низ.

  + Знакът за диез в символен низ е просто знак за диез.

  + Няколко примера:

    # this is the first comment
    SPAM = 1                 # and this is the second comment
                             # ... and now a third!
    STRING = "# This is not a comment."


** 3.1. Използване на Питон като калкулатор

   Нека изпробваме няколко прости команди на Питон.

   Стартираме интерпретатора и изчакваме появяването на първичния
   промпт, ‘>>> ’. (Това не би трябвало да отнеме много време.)


*** 3.1.1. Числа

    Интерпретаторът действа като прост калкулатор – можем да въвеждаме
    изрази в него и той ще извежда стойността им.  Синтаксисът на
    изразите е недвусмислен – операторите +, -, * и / работят точно по
    същия начин, както и в повечето други езици (напр. Паскал или C);
    могат да се използват скоби за групиране. Например:

        >>> 2+2
        4
        >>> # Това е коментар
        ... 2+2
        4
        >>> 2+2  # и един коментар на същия ред заедно с кода
        4
        >>> (50-5*6)/4
        5
        >>> # Целочисленото деление връща цялата част:
        ... 7/3
        2
        >>> 7/-3
        -3

    Знакът `=' се използва за присвояване на стойност на променлива.
    След присвояването не се извежда какъвто и да било резултат преди
    следващия интерактивен промпт:

        >>> width = 20
        >>> height = 5*9
        >>> width * height
        900

    Една стойност може да бъде присвоена едновременно на няколко
    променливи:

        >>> x = y = z = 0 # Нулираме x, y и z
        >>> x
        0
        >>> y
        0
        >>> z
        0

    Променливите трябва да бъдат „дефинирани“ (да им се присвои
    стойност) преди да бъдат използвани, иначе възниква грешка:

        >>> # опитваме да достъпим недефинирана променлива
        ... n
        Traceback (most recent call last):
        File "<stdin>", line 1, in <module>
        NameError: name 'n' is not defined

    Пълна поддръжка на плаваща запетая; операторите със смесен тип на
    операндите превръщат целочисления си операнд в тип с плаваща
    запетая:

        >>> 3 * 3.75 / 1.5
        7.5
        >>> 7.0 / 2
        3.5

    Поддръжка на комплексни числа.

    В интерактивен режим, последният изведен израз е присвоен на
    променливата `_'.  Това означава, че когато използвате Питон като
    настолен калкулатор, ще е малко по-лесно да продължите
    изчисленията, например:

        >>> tax = 12.5 / 100
        >>> price = 100.50
        >>> price * tax
        12.5625
        >>> price + _
        113.0625
        >>> round(_, 2)
        113.06

    Трябва да разглеждаме тази променлива като „само за четене“.  Не
    бива да ѝ присволяваме стойност явно – това ще създаде независима
    локална променлива със същото име, скриваща вградената променлива
    с магическо поведение.


*** 3.1.2. Символни низове

    Освен с числа, Питон може да борави и със символни низове, които
    могат да бъдат изразени по няколко начина.  Те могат да са
    затворени в единични или двойни кавички:

        >>> 'spam eggs'
        'spam eggs'
        >>> 'doesn\'t'
        "doesn't"
        >>> "doesn't"
        "doesn't"
        >>> '"Yes," he said.'
        '"Yes," he said.'
        >>> "\"Yes,\" he said."
        '"Yes," he said.'
        >>> '"Isn\'t," she said.'
        '"Isn\'t," she said.'

    Символните низове могат да се прострат на повече редове по няколко
    начина.  Поставянето на обратно наклонена черта (\) като последен
    символ на реда показва, че следващият ред е логическо продължение
    на текущия:

        hello = "Това е доста дълъг символен низ, съдържащ\n\
        няколко реда текст така както бихте го направили в C.\n\
            Забележете, че празното пространство в началото на реда\
         има значение.\n"
        print hello

    Обърнете внимание, че новите редове трябва да се отбелязват с
    `\n'.  Символите за нов ред след обратно наклонената черта се
    пренебрегват.  Този пример ще изведе следното:

        Това е доста дълъг символен низ, съдържащ
        няколко реда текст така както бихте го направили в C.
            Забележете, че празното пространство в началото на реда има значение.

    Или пък, символните низове могат да бъдат затворени в тройни
    кавички: """ или '''.  Когато използваме тройните кавички, няма
    нужда да екранираме края на редовете, но те ще бъдат включени в
    символния низ.

        print """
        Usage: thingy [OPTIONS]
             -h                        Display this usage message
             -H hostname               Hostname to connect to
        """

    предизвиква следния изход:

        Usage: thingy [OPTIONS]
             -h                        Display this usage message
             -H hostname               Hostname to connect to

    Ако направим символния литерал като „суров“ (raw) символен низ,
    тогава последователностите от символи `\n' не се превръщат в нови
    редове.  Обратно наклонените черти и новите редове в изходния код
    също се включват в символния низ като данни.  Например:

        hello = r"Това е доста дълъг символен низ съдържащ\n\
        няколко реда текст така, както бихме го направили в C."

        print hello

    би извело:

        Това е доста дълъг символен низ съдържащ\n\
        няколко реда текст така, както бихме го направили в C.

    Интерпретаторът извежда резултата от операциите със символни
    низове по същия начин, по който те са въведени — в кавички, а
    кавичките и другите забавни знаци са предшествани от обратно
    наклонена черта, за да се покаже точната стойност.  Символният низ
    е затворен в двойни кавички, ако съдържа единична кавичка и не
    съдържа никакви двойни кавички.  В противен случай символният низ
    е затворен в единични кавички.  (Твърдението `print', описано
    по-долу, може да бъде използван за отпечатване на символни низове
    без кавички и екраниращи последователности.)

    Символните низове могат да бъдат сливани (слепвани заедно) чрез
    оператора `+', и повтаряни с `*':

        >>> word = 'Help' + 'A'
        >>> word
        'HelpA'
        >>> '<' + word*5 + '>'
        '<HelpAHelpAHelpAHelpAHelpA>'

    Два символни литерала един до друг се събират автоматично –
    първият ред по-горе може да бъде написан като

        word = 'Help' 'A'

    Това работи само със символни литерали, а не с произволни изрази,
    оценявани до символни низове.

        >>> 'str' 'ing'                   #  <-  Това е добре
        'string'
        >>> 'str'.strip() + 'ing'   #  <-  Това е добре
        'string'
        >>> 'str'.strip() 'ing'     #  <-  Това е невалидно
          File "<stdin>", line 1, in ?
            'str'.strip() 'ing'
                              ^
        SyntaxError: invalid syntax

    Символните низове могат да бъдат реферирани по индекс.  Подобно на
    C, първият символ един низа има индекс 0.  Не съществува отделен
    тип за самостоятелен символ (char) – символът е просто низ с
    дължина едно.  Подобно на езика Icon, поднизовете могат да бъдат
    определяни чрез /нотацията за изрязване/ – два индекса, разделени
    с двоеточие.

        >>> word[4]
        'A'
        >>> word[0:2]
        'He'
        >>> word[2:4]
        'lp'

    Индексите на изрезките имат смислени стойности по подразбиране.
    Пропуснатият първи индекс нулева стойност по подразбиране, а
    пропуснатият втори индекс по подразбиране има за стойност
    дължината на низа, който бива изрязван.

        >>> word[:2]    # Първите два символа
        'He'
        >>> word[2:]    # Всичко, с изключение на първите два символа
        'lpA'

    За разлика от C и подобно на Java, символните низове в Питон не
    могат да бъдат променяни.  Опитът за присвояване на индексирана
    позиция в символен низ предизвиква грешка:

        >>> word[0] = 'x'
        Traceback (most recent call last):
          File "<stdin>", line 1, in ?
        TypeError: object does not support item assignment
        >>> word[:1] = 'Splat'
        Traceback (most recent call last):
          File "<stdin>", line 1, in ?
        TypeError: object does not support slice assignment

    Обаче създаването на нов символен низ от комбинирано съдържание е
    лесно и ефективно:

        >>> 'x' + word[1:]
        'xelpA'
        >>> 'Splat' + word[4]
        'SplatA'

    Ето и едно полезно свойство на изрязващите операции: s[:i] + s[i:]
    е равно на s.

        >>> word[:2] + word[2:]
        'HelpA'
        >>> word[:3] + word[3:]
        'HelpA'

    Извратените индекси за изрязване се обработват с милост:

        - индекс, който е твъде голям, се заменя с размера на
          символния низ;

        - ако горната граница на идекса е по-малка от долната, се
          връща празен символен низ.

        >>> word[1:100]
        'elpA'
        >>> word[10:]
        ''
        >>> word[2:1]
        ''

    Индексите могат да имат отрицателни стойности, като тогава
    броенето започва от дясно на ляво.  Например:

        >>> word[-1]  # Последният символ
        'A'
        >>> word[-2]  # Предпоследният символ
        'p'
        >>> word[-2:] # Последните два символ
        'pA'
        >>> word[:-2] # Всичко освен последните два символ
        'Hel'

    Забележете обаче, че -0 наистина е същото като 0, така че не се
    брои от дясно на ляво!

        >>> word[-0]        # (тъй като -0 е равно на 0)
        'H'

    Отрицателните индекси за изрязване, излизащи извън рамките на
    символния низ, се окастрят.  Но не опитвайте това с индексите за
    единичен елемент (т.е. когато не изрязвате).

        >>> word[-100:]
       'HelpA'
       >>> word[-10]    # грешка
       Traceback (most recent call last):
         File "<stdin>", line 1, in ?
       IndexError: string index out of range

    Един възможен начин да запомните как работи изрязването е като
    мислите за индексите като за сочещи /между/ символите, като левия
    край на първия символ е номериран с 0.  Тогава десният край на
    последния символ от низ, състоящ се от /n/ символа има индекс /n/,
    например:

        +---+---+---+---+---+
        | H | e | l | p | A |
        +---+---+---+---+---+
        0   1   2   3   4   5
       -5  -4  -3  -2  -1

    Първият ред от числа дава позицията на индексите 0...5 в символния
    низ; вторият ред дава съответните им отрицателни индекси.
    Изрезката от /i/ до /j/ съдържа всички знаци между краищата,
    отбелязани с /i/ и /j/, респективно.

    За неотрицателните индекси дължината на изрезката е разликата
    между индексите, ако и двата са в рамките на символния низ.
    Сиреч, дължината на `word[1:3]' е `2'.

    Вградената функция `len()' връща дължината на даден символен низ:

        >>> s = 'непротивоконституционствувателствувайте'
        >>> len(s)
        78


*** 3.1.3. Символни низове от тип Уникод

    + Типът е въведен за първи път в Питон 2.0

    + Няколко думи за Уникод

    + Разлики между обикновените низове и Уникод-низовете

      - примери с len()

    Създаването на Уникод-низове е също толкова просто, колкото и
    създаването на обикновени символни низове:

         >>> u'Hello World !'
         u'Hello World !'

    + Малката буква `u' пред кавичката показва, че трябва да се
    създаде Уникод низ.

    + Ако искате да включите специални символи в низа,
      можете да го направите чрез кодирането /Unicode-Escape/.

          >>> u'Hello\u0020World !'
          u'Hello World !'

    + Екраниращата последователност `\u0020' означава, че на дадената
      позиция трябва да се вмъкне Уникод-символ с шестнадесетично
      число 0x0020 (знак за интервал).

    + Останалите символи се интерпретират и превръщат в Уникод спрямо
      текущото кодиране на изходния код (вж. 2.2.3. Кодиране на
      изходния код).

    + „Суров“ режим за Уникод-низовете, подобно на този за
      обикновените низове.

      - префиксът е `ur'

      - кодиране Raw-Unicode-Escape – превръщането на `\uXXXX' се
        прилага само при нечетен брой обратно наклонени черти преди
        малкото `u'.
      
          >>> ur'Hello\u0020World !'
          u'Hello World !'
          >>> ur'Hello\\u0020World !'
          u'Hello\\\\u0020World !'

      - Суровият режим е най-ценен когато въвеждаме много обратно
        наклонени черти, напр. когато работим с регулярни изрази.

    + Други начини за създаване на Уникод-низове

    + Вградената функция unicode() предоставя достъп до всички
      официално регистрирани кодеци (КОДЕК означава КОдер и ДЕКодер) в
      организацията на Уникод.  Някои от най-известните кодирания,
      които тези кодеци могат да превръщат, са:

        - Latin-1
        - ASCII
        - UTF-8
        - UTF-16.

    + Последните две са кодирания с променлив размер, позволяващи
      съхраняване на Уникод-символи в един или повече байтове.

    + Питон по подразбиране обикновено използва кодирането ASCII,
      който приема символи с код от 0 до 127 и отхвърля всички
      останали със съобщение за грешка.

    + Когато един Уникод-низ бива изведен на екрана, записан във файл,
      или конвертиран с функцията `str()', превръщането се прави
      спрямо това кодиране по подразбиране.

        >>> u"abc"
        u'abc'
        >>> str(u"abc")
        'abc'
        >>> u"душ"
        u'\u0434\u0443\u0448'
        >>> str(u"душ")
        Traceback (most recent call last):
        File "<stdin>", line 1, in ?
        UnicodeEncodeError: 'ascii' codec can't encode characters in
                            position 0-2: ordinal not in range(128)

     + За да превърнем Уникод-низ в 8-битов низ в дадено конкретно
       кодиране, Уникод-обектите предоставят метода `encode()', който
       приема един аргумент – името на кодирането.  Препоръчително е
       имената на кодиранията да се дават с редовни букви.

         >>> u"душ".encode('utf-8')
         '\xd0\xb4\xd1\x83\xd1\x88'
                            
     + Ако имаме данни в дадено конкретно кодиране и искаме от него да
       получим съответния Уникод-низ, можем да използваме функцията
       `unicode()', като името на кодирането се подава като втори
       аргумент.

         >>> unicode('\xd0\xb4\xd1\x83\xd1\x88', 'utf-8')
         u'\u0434\u0443\u0448'

*** 3.1.4. Списъци

    Питон познава няколко съставни (compound) типа данни, използвани
    за групиране на стойности.  Най-гъвкавият от тях е списъкът
    (list), който може да бъде изписан като поредица от разделени със
    запетая стойности (елементи, items) между квадратни скоби.  Не е
    нужно елементите от списъка да бъдат от един и същ тип.

        >>> a = ['spam', 'eggs', 100, 1234]
        >>> a
        ['spam', 'eggs', 100, 1234]

    Подобно на индексите на символните низове, индексите на списъците
    започват от 0.  Списъците също могат да бъдат изрязвани, сливани и
    прочие:

        >>> a[0]
        'spam'
        >>> a[3]
        1234
        >>> a[-2]
        100
        >>> a[1:-1]
        ['eggs', 100]
        >>> a[:2] + ['bacon', 2*2]
        ['spam', 'eggs', 'bacon', 4]
        >>> 3*a[:3] + ['Boo!']
        ['spam', 'eggs', 100, 'spam', 'eggs', 100, 'spam', 'eggs', 100, 'Boo!']

    Всички операции по изрязване връщат нов списък, съдържащ желаните
    елементи.  Това означава, че следната изрезка връща „плитко“ копие
    на списъка `a':

        >>> a[:]
        ['spam', 'eggs', 100, 1234]

    За разлика от символните низове, които са /неизменяеми/, в списък
    е възможно да се подменят индивидуални елементи.

        >>> a
        ['spam', 'eggs', 100, 1234]
        >>> a[2] = a[2] + 23
        >>> a
        ['spam', 'eggs', 123, 1234]

    Присвояването на изрезки също е възможно, като това дори може да
    промени размера на списъка:

        >>> # Заменя някои елементи:
        ... a[0:2] = [1, 12]
        >>> a
        [1, 12, 123, 1234]
        >>> # Премахва други:
        ... a[0:2] = []
        >>> a
        [123, 1234]
        >>> # Вмъква трети:
        ... a[1:1] = ['bletch', 'xyzzy']
        >>> a
        [123, 'bletch', 'xyzzy', 1234]
        >>> #  Вмъква (копие от) себе си в началото
        >>> a[:0] = a
        >>> a
        [123, 'bletch', 'xyzzy', 1234, 123, 'bletch', 'xyzzy', 1234]
        >>> # Изчиства списъка: заменя всички елементи с празен списък
        >>> a[:] = []
        >>> a
        []

    Вградената функция len() важи и за списъците:

        >>> a = ['a', 'b', 'c', 'd']
        >>> len(a)
        4

    Възможно е списъците да се влагат каскадно един в друг (да се
    създават списъци, съдържащи други списъци), например:

        >>> q = [2, 3]
        >>> p = [1, q, 4]
        >>> len(p)
        3
        >>> p[1]
        [2, 3]
        >>> p[1][0]
        2
        >>> p[1].append('xtra')     # Виж раздел 5.1
        >>> p
        [1, [2, 3, 'xtra'], 4]
        >>> q
        [2, 3, 'xtra']

    Обърнете внимание, че в последния пример `p[1]' и `q' в
    действителност отпращат към един и същи обект!  По-късно ще се
    върнем отново на /обектната семантика/.


** 3.2. Първи стъпки в програмирането

    Разбира се, можем да използваме Питон за по-сложни задачи от
    събиране на две и две.  Например можем да изведем началните числа
    от редицата на Фибоначи ето така:

        >>> # Редица на Фибоначи:
        ... # сборът на два елемента определя следващия
        ... a, b = 0, 1
        >>> while b < 10:
        ...     print b
        ...     a, b = b, a+b
        ...
        1
        1
        2
        3
        5
        8

    Този пример въвежда няколко нови свойства.

    – Първият ред съдържа /множествено присвояване/: променливите `a'
      и `b' едновременно получават новите стойности `0' и `1'.  В
      последния ред това е използвано отново, показвайки че изразите
      от дясната страна се изчисляват преди каквото и да било
      присвояване.  Изразите от дясната страна се изчисляват от ляво
      на дясно.

    – Цикълът `while' се изпълнява дотогава, докато условието (в
      случая: `b < 10') е вярно.  В Питон, подобно на C, всяка
      ненулева стойност е истина; нула е неистина.  Също така,
      условието може да бъде символен низ или списък, всъщност каквато
      и да е редица (sequence).  Всичко с ненулева дължина е истина,
      празните редици са неистина.  Проверката, използвана в примера,
      е просто сравнение.  Стандартните оператори за сравнение се
      изписват по същия начин, както и в C: `<' (по-малко), `>'
      (по-голямо), `==' (равно), `<=' (по-малко или равно), `>='
      (по-голямо или равно) и `!=' (неравно).

    – /Тялото/ на цикъла е с /отстъп/: отстъпът е начинът на Питон за
      групиране на конструкциите.  Питон не предлага (засега!)
      интелигентно средство за редактиране на редовете, така че ще
      трябва да въвеждате табулация или интервал(и) за всеки ред с
      отстъп.  На практика ще подготвяте по-сложния вход за Питон с
      текстов редактор; повечето текстови редактори имат средство за
      автоматичен отстъп.  Когато съставна конструкция се въвежда
      интерактивно, то трябва да бъде последвано от празен ред за да
      се укаже, че е приключило (тъй като граматичният анализатор не
      може да познае кога сме написали последния ред).  Обърнете
      внимание, че всички редове, образуващи общ блок, трябва да бъдат
      с еднакъв отстъп.

    – Операторът `print' извежда стойността на израза (или изразите),
      които са му подадени.  Той се различава от простото извеждане на
      израза, който искате да покажете (както правихме по-горе в
      примерите с калкулатора), по начина по който се обработват
      символните низове и съставните изрази.  Символните низове се
      отпечатват без кавички и между елементите се вмъква интервал,
      така че можете добре да форматирате нещата.  Например:

          >>> i = 256*256
          >>> print 'Стойността на i е', i
          Стойността на i е 65536

      Чрез оставена накрая запетайка се избягва преминаването на нов
      ред след изхода.

          >>> a, b = 0, 1
          >>> while b < 1000:
          ...     print b,
          ...     a, b = b, a+b
          ...
          1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987

      Обърнете внимание, че в случай че последният ред не е бил
      завършен, интерпретаторът вмъква нов ред преди да е показал
      следващия си промпт.
